package cs451.links;

import cs451.Deliverer;
import cs451.messages.Message;

import javax.swing.text.html.Option;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

public class PerfectLink implements Runnable, Deliverer {
    private FairLossLink fairLossLink;
    private Map<Tuple<Integer, Long>, Message> buffer;
    private final Deliverer deliverer;

    public PerfectLink(Deliverer deliverer, int port) {
        this.deliverer = deliverer;
        fairLossLink = new FairLossLink(this, port);
        buffer = new HashMap<Tuple<Integer, Long>, Message>();
        Thread fairLossThread = new Thread(fairLossLink);
        fairLossThread.start();
    }

    @Override
    public void run() {
        while (true) {
            //TODO resend a message only if it timed out (one timer per message)
            buffer.forEach((id,message) -> fairLossLink.send(message));
            try {
                Thread.sleep(400);
            } catch (InterruptedException e) {
                System.out.print("Thread interrupted");
                e.printStackTrace();
            }
        }
    }

    public void send(Message message) {
        if (message.getContent().equals("ack")) {
            //TODO improve
            return;
        }
        buffer.put(new Tuple(message.getDest().getId(), message.getId()), message);
    }

    @Override
    public void deliver(Message message) {
        System.out.println("###DEBUG : "+message.getContent());
        //TODO : add an atribute "isAck" in Message or Inheritance to avoid random conversion
        if (message.getContent().equals("ack")) {
            buffer.remove(new Tuple<Integer, Long>(message.getSender().getId(), message.getId()));
            return;
        } else {
            fairLossLink.send(new Message(message.getId(), "ack", message.getDest(), message.getSender()));
            deliverer.deliver(message);
        }
    }

    //First part of this class comes from StackOverflow, equals and hashcode were generated by my IDE
    public class Tuple<X, Y> {
        public final X x;
        public final Y y;
        public Tuple(X x, Y y) {
            this.x = x;
            this.y = y;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Tuple<?, ?> tuple = (Tuple<?, ?>) o;
            return Objects.equals(x, tuple.x) &&
                    Objects.equals(y, tuple.y);
        }

        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }
}
